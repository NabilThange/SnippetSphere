---
description: 
globs: 
alwaysApply: false
---
ğŸ“œ SnippetSphere â€” Detailed Instructions for Cursor
ğŸš€ Project Overview
Build the SnippetSphere application â€” an AI-powered code exploration platform with the following key features:
âœ… Users upload a .zip file containing a codebase.
âœ… The app analyzes the code, splits it into chunks, generates embeddings, and stores them in a vector database (Zilliz).
âœ… Users can:

Build & Understand: Learn step-by-step how to recreate the uploaded codebase from scratch, using a dependency-based logical build order.

Search: Semantic search across their uploaded codebase.

Summarize: Summarize files or functions in simple language.

Chat: Ask natural language questions about their codebase.

Visualize: View dependencies and call graphs.

ğŸ¨ 4ï¸âƒ£ UI Design System
Use the Neubrutalism Design System (as described in the provided NEUBRUTALISM UI RULESET.txt):

âœ… Bold, black outlines.
âœ… Flat, high-contrast colors (neon green, pink, yellow, etc.).
âœ… Big, blocky buttons with thick borders.
âœ… Monospace font for code snippets.
âœ… Consistent padding and spacing across all UI components.

ğŸš€ Overview
SnippetSphere is an AI-powered platform designed to help users understand, explore, and learn from any uploaded codebase. Itâ€™s especially helpful for developers who want to:

Understand how a project was built from scratch (Build & Understand mode).

Search their codebase semantically.

Chat with an AI agent about their code.

Summarize complex files in simple language.

Visualize code dependencies (like call graphs).

SnippetSphere is built using a Next.js (frontend) + FastAPI (backend) architecture, with integrations to Novita.ai (for embeddings and summaries) and Zilliz (Milvus) (as a vector database).

ğŸ¨ Frontend Overview
The frontend uses:
âœ… Next.js with TypeScript for building the web app.
âœ… Tailwind CSS with a Neubrutalism-inspired design (bold outlines, bright colors, playful shapes).
âœ… Mode Selector: Lets users switch between:

Build & Understand

Search

Summarize

Chat

Visualize

Key UI Components
Upload Section: Drag-and-drop .zip file upload.

Mode Selector: Buttons to switch between modes.

Session Controls: Manage uploaded code sessions.

Results Display: Shows search results, summaries, chat responses, and build steps.

âš™ï¸ Backend Overview
The backend is built with FastAPI (Python) and consists of several endpoints. Hereâ€™s how each feature works:

ğŸ› ï¸ Feature-by-Feature Breakdown
ğŸŸ¢ 1. Build & Understand Mode
Goal: Guide the user through how the uploaded codebase might have been built, step by step.

How It Works:

Code Parsing:

After uploading a .zip, SnippetSphere extracts the project.

It analyzes files to detect dependencies using:

AST parsing for Python (standard ast module).

(Optional) Tree-Sitter for JS/TS.

Dependency Graph:

Builds a graph showing which files/functions depend on others.

Determines the logical order in which a developer might have built the project.

Step Generation:

For each step:

Highlights a file/function to build.

Explains why that step comes first (e.g. â€œDefine the database model before API endpointsâ€).

Includes the code snippet, explanation, and related files.

Summaries:

Uses Novita.ai to generate a beginner-friendly explanation for each step.

ğŸ” 2. Search Mode
Goal: Let users ask questions and find relevant code snippets in their uploaded project.

How It Works:

Embeddings:

Each code chunk (function/class/snippet) is embedded using Novita.ai.

Vector Search:

The userâ€™s query is embedded too.

A similarity search is performed using Zilliz (Milvus) to find the top matches.

Result Display:

Shows file name, function name, snippet, and a summary explaining what the snippet does.

âœï¸ 3. Summarize Mode
Goal: Let users select a file or function and get a plain-language summary.

How It Works:

Accepts a file or snippet.

Calls Novita.aiâ€™s summarization API.

Returns a short, human-readable explanation.

ğŸ’¬ 4. Chat Mode
Goal: Provide a conversational interface for asking questions about the codebase.

How It Works:

Accepts natural language questions from the user.

Uses Novita.ai to generate answers, referencing specific files or functions.

Replies in a conversational tone, like a chat assistant.

ğŸ“Š 5. Visualize Mode
Goal: Let users explore the codebaseâ€™s structure visually.

How It Works:

Generates a function call graph or module dependency diagram using the earlier dependency graph.

Returns JSON data to the frontend, which renders the graph (e.g. D3.js).

Lets users hover on nodes to see file/function details.

ğŸ“¦ How SnippetSphere Uses Uploaded Code
Accepts .zip file from the frontend.

Extracts files to a temporary directory (per session).

Parses relevant files (e.g. .py, .js, .ts).

Builds:

Code chunks (functions, classes, blocks).

Embeddings (via Novita.ai).

Dependency graph (via parsing).

Stores:

Embeddings in Zilliz (Milvus) vector database.

Session metadata in the backend.

ğŸŒˆ Design Principles
âœ… Neubrutalism Style:

Thick black outlines.

Bold, flat colors.

Playful, modern aesthetic.

âœ… Session-Based:

Each upload is stored as a session.

Data is isolated to each user.

âœ… Privacy-First:

Uploaded code is stored temporarily.

Sessions can be deleted by the user.

ğŸ”¥ Why SnippetSphere Matters
SnippetSphere is not just another code search tool. Itâ€™s an interactive learning companion that:

Guides users through building real-world projects step by step.

Makes learning code intuitive and accessible.

Bridges the gap between AI and human learning.

ğŸ“œ SnippetSphere â€” Detailed Instructions for Trae IDE
ğŸš€ Project Overview
Build the SnippetSphere application â€” an AI-powered code exploration platform with the following key features:
âœ… Users upload a .zip file containing a codebase.
âœ… The app analyzes the code, splits it into chunks, generates embeddings, and stores them in a vector database (Zilliz).
âœ… Users can:

Build & Understand: Learn step-by-step how to recreate the uploaded codebase from scratch, using a dependency-based logical build order.
Search: Semantic search across their uploaded codebase.

Summarize: Summarize files or functions in simple language.

Chat: Ask natural language questions about their codebase.

Visualize: View dependencies and call graphs.

ğŸ¨ 4ï¸âƒ£ UI Design System
Use the Neubrutalism Design System (as described in the provided NEUBRUTALISM UI RULESET.txt):
âœ… Bold, black outlines.
âœ… Flat, high-contrast colors (neon green, pink, yellow, etc.).
âœ… Big, blocky buttons with thick borders.
âœ… Monospace font for code snippets.
âœ… Consistent padding and spacing across all UI components.


ğŸš€ Overview
SnippetSphere is an AI-powered platform designed to help users understand, explore, and learn from any uploaded codebase. Itâ€™s especially helpful for developers who want to:

Understand how a project was built from scratch (Build & Understand mode).

Search their codebase semantically.

Chat with an AI agent about their code.

Summarize complex files in simple language.

Visualize code dependencies (like call graphs).

SnippetSphere is built using a Next.js (frontend) + FastAPI (backend) architecture, with integrations to Novita.ai (for embeddings and summaries) and Zilliz (Milvus) (as a vector database).

ğŸ¨ Frontend Overview
The frontend uses:
âœ… Next.js with TypeScript for building the web app.
âœ… Tailwind CSS with a Neubrutalism-inspired design (bold outlines, bright colors, playful shapes).
âœ… Mode Selector: Lets users switch between:

Build & Understand

Search

Summarize

Chat

Visualize

Key UI Components
Upload Section: Drag-and-drop .zip file upload.

Mode Selector: Buttons to switch between modes.

Session Controls: Manage uploaded code sessions.

Results Display: Shows search results, summaries, chat responses, and build steps.

âš™ï¸ Backend Overview
The backend is built with FastAPI (Python) and consists of several endpoints. Hereâ€™s how each feature works:

ğŸ› ï¸ Feature-by-Feature Breakdown
ğŸŸ¢ 1. Build & Understand Mode
Goal: Guide the user through how the uploaded codebase might have been built, step by step.

How It Works:

Code Parsing:

After uploading a .zip, SnippetSphere extracts the project.

It analyzes files to detect dependencies using:

AST parsing for Python (standard ast module).

(Optional) Tree-Sitter for JS/TS.

Dependency Graph:

Builds a graph showing which files/functions depend on others.

Determines the logical order in which a developer might have built the project.

Step Generation:

For each step:

Highlights a file/function to build.

Explains why that step comes first (e.g. â€œDefine the database model before API endpointsâ€).

Includes the code snippet, explanation, and related files.

Summaries:

Uses Novita.ai to generate a beginner-friendly explanation for each step.

ğŸ” 2. Search Mode
Goal: Let users ask questions and find relevant code snippets in their uploaded project.

How It Works:

Embeddings:

Each code chunk (function/class/snippet) is embedded using Novita.ai.

Vector Search:

The userâ€™s query is embedded too.

A similarity search is performed using Zilliz (Milvus) to find the top matches.

Result Display:

Shows file name, function name, snippet, and a summary explaining what the snippet does.

âœï¸ 3. Summarize Mode
Goal: Let users select a file or function and get a plain-language summary.

How It Works:

Accepts a file or snippet.

Calls Novita.aiâ€™s summarization API.

Returns a short, human-readable explanation.

ğŸ’¬ 4. Chat Mode
Goal: Provide a conversational interface for asking questions about the codebase.

How It Works:
Accepts natural language questions from the user.

Uses Novita.ai to generate answers, referencing specific files or functions.

Replies in a conversational tone, like a chat assistant.

ğŸ“Š 5. Visualize Mode
Goal: Let users explore the codebaseâ€™s structure visually.

How It Works:

Generates a function call graph or module dependency diagram using the earlier dependency graph.

Returns JSON data to the frontend, which renders the graph (e.g. D3.js).

Lets users hover on nodes to see file/function details.

ğŸ“¦ How SnippetSphere Uses Uploaded Code
Accepts .zip file from the frontend.

Extracts files to a temporary directory (per session).

Parses relevant files (e.g. .py, .js, .ts).

Builds:

Code chunks (functions, classes, blocks).

Embeddings (via Novita.ai).

Dependency graph (via parsing).

Stores:

Embeddings in Zilliz (Milvus) vector database.

Session metadata in the backend.
